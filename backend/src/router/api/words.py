from fastapi import APIRouter, Depends, HTTPException
from typing import List

# Config
from sqlalchemy.orm import Session
from sqlalchemy import func
from config.database import get_db
from config.auth import get_current_user
from config.settings import Settings

# Models
from database.models.words import Word
from database.models.user_tasks import UserTask
from database.models.rel_user_tasks_words import RelUserTaskWord
from database.models.word_sentences import WordSentence
from database.models.word_definitions import WordDefinition

# Schemas
from database.schemas.words import (
    GenerateWordInformation,
    GenerateWordAudio,
    WordViewWithoutRelationships
)
from database.schemas.user_tasks import (
    UserTaskView
)

# Cruds
from database import cruds

# Lib
from lib.chat_gpt import ChatGptManager
from lib.google_tts import GoogleTTSManager
from lib.google_cloud_storage import GCSManager
from lib.helper import spacesToDash

# Native
import json

router = APIRouter(prefix="/words", tags=["words"])
settings = Settings()

# @router.post("/create", description="Create words (Test only)")
# def createWord(data: CreateWord, db: Session = Depends(get_db), user=Depends(get_current_user)):
#     for word in data.words:
#         instance = Word()
#         instance.word = word
#         db.add(instance)

#     db.commit()
#     return {
#         "detail": "success"
#     }


# @router.get("/random", response_model=List[WordView], description="Fetch all words from database.")
# def get_random_words(db: Session = Depends(get_db), user=Depends(get_current_user)):
#     words = db.query(Word).order_by(func.random()).limit(5).all()
#     return words


# Generate Audios with Google TTS
@router.post("/generate-audio", response_model=WordViewWithoutRelationships, description="Generate audio for word.")
def generateAudio(data: GenerateWordAudio, db: Session = Depends(get_db), user=Depends(get_current_user)):
    instance = db.query(Word).filter(Word.id == data.word_id).first()
    gcsManager = GCSManager()

    if not instance:
        raise HTTPException(status_code=404, detail="There is no such word.")

    # Generate US Audio
    if not instance.us_audio:
        ttsManager = GoogleTTSManager()
        response = ttsManager.generateTTS(text=instance.word)
        dest_name = f"{spacesToDash(instance.word.lower())}/us.ogg"
        public_url = gcsManager.upload_blob_from_memory(
            data=response.audio_content, bucket_name="i-learn", destination_blob_name=dest_name)
        instance = cruds.words.put(db=db, record=instance, data={
            "us_audio": public_url
        })

    # Generate UK Audio
    if not instance.uk_audio:
        ttsManager = GoogleTTSManager(language_code="en-UK")
        response = ttsManager.generateTTS(text=instance.word)
        dest_name = f"{spacesToDash(instance.word.lower())}/uk.ogg"
        public_url = gcsManager.upload_blob_from_memory(
            data=response.audio_content, bucket_name="i-learn", destination_blob_name=dest_name)
        instance = cruds.words.put(db=db, record=instance, data={
            "uk_audio": public_url
        })

    return instance


# Generate Definition and Sentences with GPT
@router.post("/generate-information", response_model=UserTaskView, description="Generate word information with Open AI.")
def generateWordInformation(data: GenerateWordInformation, db: Session = Depends(get_db), user=Depends(get_current_user)):
    task = db.query(UserTask).filter(UserTask.user_id == user["sub"]).filter(
        UserTask.id == data.task_id).first()

    if not task:
        raise HTTPException(status_code=404, detail="There is no such task.")

    rel_task_words = db.query(RelUserTaskWord).filter(
        RelUserTaskWord.task_id == task.id).all()

    # Fetch words from instances of rel_task_words.
    words_arr = []

    for instance in rel_task_words:
        # If definition and sentence not exist, it means this word does not have data generated by AI.
        word_sentence = db.query(WordSentence).filter(
            WordSentence.word_id == instance.word_id).first()
        word_definition = db.query(WordDefinition).filter(
            WordDefinition.word_id == instance.word_id).first()

        if not word_sentence and not word_definition:
            temp = {
                "word": instance.word.word,
                "id": instance.word_id
            }
            words_arr.append(temp)

    if len(words_arr):
        gptManager = ChatGptManager(access_token=settings.OPEN_AI_ACCESS_TOKEN)
        gpt_word_data = gptManager.createWordData(
            words=[i["word"] for i in words_arr])

        if not gpt_word_data:
            raise HTTPException(
                status_code=500, detail="An error occured while creating word data.")

        for gpt_word in gpt_word_data:
            for word_instance_obj in words_arr:
                if gpt_word["word"].lower() == word_instance_obj["word"].lower():
                    # 1 - Create Word Descriptions
                    for definition in gpt_word["definitions"]:
                        cruds.word_definitions.put(db=db, data={
                            "word_id": word_instance_obj["id"],
                            "definition": definition["definition"],
                            "part_of_speech": definition["part_of_speech"]
                        })

                    # 2- Create Word Sentences
                    for sentence in gpt_word["sentences"]:
                        cruds.word_sentences.put(db=db, data={
                            "word_id": word_instance_obj["id"],
                            "sentence": sentence["sentence"],
                            "part_of_speech": sentence["part_of_speech"]
                        })

                    # Update word's part of speech.
                    word = db.query(Word).filter(
                        Word.id == word_instance_obj["id"]).first()

                    word = cruds.words.put(db=db, record=word, data={
                        "part_of_speech": json.dumps(gpt_word["part_of_speeches"])
                    })

    return task
